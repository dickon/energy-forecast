# %%
# needs python3 .8
import pypowerwall, traceback, re, datetime, pprint, sys, time, requests, pysolar
from dateutil.parser import isoparse
from typing import NamedTuple
import influxdb_client
from influxdb_client.client.write_api import SYNCHRONOUS
from solar_model import lat_long_solar_model
from collections import namedtuple
import json
import os.path


class Costs(NamedTuple):
    electric_sc: float
    electric_import_rate: float
    electric_export_rate: float
    gas_sc: float
    gas_import_rate: float


class InfluxConfig(NamedTuple):
    token: str
    server: str
    bucket: str
    org: str


class PowerwallConfig(NamedTuple):
    password: str
    address: str
    email: str
    timezone: str
    commission_date: str


class OctopusConfig(NamedTuple):
    url: str
    api_key: str
    account: str


class LedgerEntry(NamedTuple):
    system: str  # the system concerned
    measurement: str
    t: datetime.datetime
    total: float


SITE = json.load(open(os.path.expanduser("~/src/powerwallextract/site.json")))


influxConfig = InfluxConfig(**SITE["influx"])
powerwallConfig = PowerwallConfig(**SITE["powerwall"])
octopusConfig = OctopusConfig(**SITE["octopus"])

t0 = smart_start = isoparse("2022-11-01T10:00:00Z")
latitude = 51.82455
longitude = -0.18741
model_scale = 1.189
t1 = tesla0 = isoparse("2023-07-30T10:00:00Z")
t_ovo_fix_end = isoparse("2023-02-24T00:00:00Z")
# t_ovo_leave = isoparse('2023-03-14T00:00:00Z')
t_ovo_leave = isoparse("2023-03-15T00:00:00Z")
t_export_start = isoparse("2023-04-13T00:00:00Z")
now = (datetime.datetime.utcnow()).replace(tzinfo=datetime.timezone.utc)
systems = ["solar", "conventional"]
field_list = ["load", "site_in", "site_out"]
pw = pypowerwall.Powerwall(
    SITE["powerwall"]["address"],
    SITE["powerwall"]["password"],
    SITE["powerwall"]["email"],
    SITE["powerwall"]["timezone"],
)
fuels = ["electricity_import", "electricity_export", "gas"]
txover = datetime.datetime.strptime("2023-07-30 00:00:00 Z", "%Y-%m-%d %H:%M:%S %z")


client = influxdb_client.InfluxDBClient(
    url=influxConfig.server, token=influxConfig.token, org=influxConfig.org
)
write_api = client.write_api(write_options=SYNCHRONOUS)
query_api = client.query_api()
tesla0 = isoparse("2023-07-30T10:00:00Z")

start = isoparse("2023-01-01T00:00:00Z")
end = isoparse("2023-12-31T00:00:00Z")

series = {}
series_highwater = {}

# generated by ~/src/forecast/forecsat.ipynb

mean_time_of_day_kwh_used = SITE["model"]["mean_time_of_day_kwh_used"]

saving_sessions_completed = [
    (isoparse("2023-11-29T17:00:00Z"), isoparse("2023-11-29T18:30:00Z"), 400.0),
    (isoparse("2023-12-01T16:30:00Z"), isoparse("2023-12-01T18:00:00Z"), 400.0),
    (isoparse("2023-12-05T17:30:00Z"), isoparse("2023-12-05T18:30:00Z"), 240.0),
    (isoparse("2023-12-14T17:00:00Z"), isoparse("2023-12-14T18:00:00Z"), 240.0),
    (isoparse("2023-12-15T17:00:00Z"), isoparse("2023-12-15T18:00:00Z"), 240.0),
]


def get_solar_position_index(t):
    altitude = pysolar.solar.get_altitude(
        latitude, longitude, t + datetime.timedelta(minutes=15)
    )
    azimuth = pysolar.solar.get_azimuth(
        latitude, longitude, t + datetime.timedelta(minutes=15)
    )
    return 5 * round(altitude / 5), 5 * round(azimuth / 5)


# %%


def determine_meters():
    out = requests.request(
        "GET",
        octopusConfig.url + "/accounts/" + octopusConfig.account,
        auth=requests.auth.HTTPBasicAuth(octopusConfig.api_key, ""),
    )
    data = out.json()
    meters = {}
    for p in data["properties"]:
        for emeter in p["electricity_meter_points"]:
            k = "export" if emeter["is_export"] else "import"
            meters["electricity_" + k] = emeter
            print(f'electricity {k} meter with MPAN={emeter["mpan"]}')
        for gmeter in p["gas_meter_points"]:
            print(gmeter)
            meters["gas_import"] = gmeter
    return meters


cache = {}  # (product, tariff, standing) -> octopus API response


def lookup_price(
    tariff, payment_method, t, standing, fallback=None, fuel="electricity", product=None
):
    """For a tariff (or product, if specified)) and payment method, work out prime at a specific time

    If standing is true then work out the daily standing charge

    Use fallback if price not known.

    Fuel can be 'electricity' (default) or 'gas'.

    Caches results inÂ memory and influx.
    """
    if product is None:
        product = "-".join(tariff.split("-")[2:-1])

    k = (product, tariff, standing)
    query = f"""from(bucket: "tariffs")
        |> range(start: { t.strftime('%Y-%m-%dT%H:%M:%SZ')}, stop: { (t+datetime.timedelta(minutes=25)).strftime('%Y-%m-%dT%H:%M:%SZ')})
        |> filter(fn: (r) => r["product"] == "{product}" and r["_measurement"] == "{'standing_charge' if standing else 'unit_cost'}" and r["fuel"] == "{fuel}")
        |> last()"""
    queryres = query_api.query(query)
    queryrec = [[x for x in y] for y in queryres]
    # print(product, standing,'results already known', queryrec)
    if queryrec and queryrec[0]:
        cost = queryrec[0][0]["_value"]
        return cost
    else:
        print(f"Influx does not have {t} charge for {fuel} standing={standing}")
    if k in cache:
        fetched = False
        results = cache[k]
    else:
        page = 1
        results = []
        while True:
            url = (
                octopusConfig.url
                + f'products/{product}/{fuel}-tariffs/{tariff}/{"standing-charges" if standing else "standard-unit-rates"}?page={page}'
            )
            out = requests.request("GET", url).json()
            if "results" not in out:
                break
            if len(out["results"]) == 0:
                break
            # print('fetch',url,'got', len(out['results']))

            results += out["results"]
            page += 1
        cache[k] = results
        fetched = True

    # out has all the time slots we want, filter it down to those intervals that cover t
    out_rate = [
        x
        for x in results
        if x["payment_method"] in [None, payment_method]
        and isoparse(x["valid_from"]) <= t
        and (x["valid_to"] is None or isoparse(x["valid_to"]) > t)
    ]
    if len(out_rate) != 1:
        print(
            f"ERROR: unable to select unique {product}:{tariff} {standing} payment method {payment_method} rate at {t}; mathces {len(out_rate)} defaulting to {fallback}"
        )
        print("candidates")
        pprint.pprint(results)
        print("matching")
        pprint.pprint(out_rate)
        return fallback

    cost = float(out_rate[0]["value_inc_vat"])
    rec = {
        "measurement": "standing_charge" if standing else "unit_cost",
        "tags": {"product": product, "fuel": fuel},
        "time": t.strftime("%Y-%m-%dT%H:%M:%SZ"),
        "fields": {"price": cost},
    }
    # print('writing for future ref to influx', rec)
    write_api.write("tariffs", "Reed", rec)
    print(
        f'{"fetched" if  fetched else  "cached"} {"standing" if standing else "kWh"} charge {cost} for product {product} tariff {tariff} at {t}'
    )
    return cost


def get_tariff(t, meters, traditional_rate=False) -> Costs:
    """Work out standing charge, import price  and export price in kWh for meters.

    Records tariffs to Influx.

    If traditional_rate is True then return costs for traditional tarirrfs rather than dnymaic tariffs.
    """
    tariffs = {}
    for meter, details in meters.items():
        for ag in details["agreements"]:
            t0 = isoparse(ag["valid_from"])
            t1t = ag["valid_to"]
            t1 = now if t1t is None else isoparse(t1t)
            if t >= t0 and (t1t is None or t < isoparse(t1t)):
                tariffs[meter] = ag["tariff_code"]

    if t <= t_ovo_fix_end:
        sc = 23.33
        import_rate = 15.59
        imp_tariff = "OVO fix"
        exp_tariff = "None"
        export_rate = 0
        gas_sc = 24.79
        gas_import_rate = 2.66
    elif t > t_ovo_fix_end and t < t_ovo_leave:
        sc = 37.08
        import_rate = 33.38
        export_rate = 0
        imp_tariff = "OVO variable"
        exp_tariff = "None"
        gas_sc = 27.12
        gas_import_rate = 9.81
    else:
        imp_tariff = tariffs["electricity_import"]
        sc = lookup_price(imp_tariff, "DIRECT_DEBIT", t, True, 42.01)
        if traditional_rate:
            import_rate = lookup_price(
                None, None, t, False, 27.9, fuel="electricity", product="VAR-22-11-01"
            )
        else:
            import_rate = lookup_price(
                imp_tariff, "DIRECT_DEBIT", t, False, 30.23, fuel="electricity"
            )
        exp_tariff = tariffs.get("electricity_export")
        if exp_tariff:
            exp_tariff = tariffs["electricity_export"]
            export_rate = lookup_price(
                exp_tariff, None, t, False, 15.00, fuel="electricity"
            )
        else:
            export_rate = 0.0
        if t < t_export_start:
            export_rate = 0.0

        gas_tariff = tariffs.get("gas_import")
        gas_sc = lookup_price(gas_tariff, "DIRECT_DEBIT", t, True, 27.47, fuel="gas")
        gas_import_rate = lookup_price(
            gas_tariff, "DIRECT_DEBIT", t, False, 2.99, fuel="gas"
        )

    # print(f'tariff {imp_tariff} and {exp_tariff} sc {sc} import_kwh={import_rate} export_kwh={export_rate}')

    for ss0, ss1, ss_p in saving_sessions_completed:
        if t >= ss0 and t <= ss1:
            export_rate += ss_p
    return Costs(
        electric_sc=sc,
        electric_import_rate=import_rate,
        electric_export_rate=export_rate,
        gas_sc=gas_sc,
        gas_import_rate=gas_import_rate,
    )


def get_starting_balance(
    t: datetime.datetime, system: str = "solar", measurement: str = "balance"
) -> LedgerEntry:
    """Work out the last total for system regarding measurement before time t"""
    t0 = isoparse("2023-01-01T10:00:00Z")
    if t < t0:
        t0 = t
        t = t0 + datetime.timedelta(minutes=30)
    query = f"""from(bucket: "modelcost")
    |> range(start: { t0.strftime('%Y-%m-%dT%H:%M:%SZ')}, stop: { t.strftime('%Y-%m-%dT%H:%M:%SZ')})
    |> filter(fn: (r) => r["_measurement"] == "{measurement}" and r["system"] == "{system}")
    |> last()"""

    mres = query_api.query(query)
    if mres:
        res = [x for x in mres[0]]
        if res:
            rec = res[0]
            # print(f'have {system} balance at {rec["_time"]} value {rec.get_value()}')
            return LedgerEntry(
                system=system,
                measurement=measurement,
                t=rec["_time"],
                total=rec.get_value(),
            )


def round30m(t):
    return t - datetime.timedelta(
        minutes=t.minute % 30, seconds=t.second, microseconds=t.microsecond
    )


def retreive_tesla_meters_before(t):
    """Work out the latest Tesla meter readings at time t"""
    try:
        data = {}
        for k in field_list:
            field = "energy_exported" if k == "site_out" else "energy_imported"
            meter = {"load": "load", "site_out": "site", "site_in": "site"}[k]
            fquery = f"""from(bucket: "powerwall") |> range(start: {(t-datetime.timedelta(minutes=30)).strftime('%Y-%m-%dT%H:%M:%SZ')}, stop: {(t).strftime('%Y-%m-%dT%H:%M:%SZ')}) |>  filter(fn: (r) => r["_measurement"] == "energy")
        |> filter(fn: (r) => r["_field"] == "{field}")
        |> filter(fn: (r) => r["meter"] == "{meter}") |> last() """
            query_res = query_api.query(org="Reed", query=fquery)
            d0 = [x for x in query_res[0]][0]
            data[k] = d0["_value"]
            t = d0["_time"]
        data["t"] = t
        for k in field_list:
            if data[k] == None:
                data[k] = 0
        return data
    except IndexError:
        print("tesla meters not available for", t)


def count_meters(t, meters):
    fuel_usage = {}
    days_count = {}
    for fuel in fuels:
        tot = get_starting_balance(t, measurement="actual_" + fuel + "_cost")
        if tot is None or tot.t < t:
            t0 = tot.t if tot else smart_start
            t1 = t + datetime.timedelta(minutes=30)
            query = f"""from(bucket: "56new")
  |> range(start: {t0.strftime('%Y-%m-%dT%H:%M:%SZ')}, stop: {t1.strftime('%Y-%m-%dT%H:%M:%SZ')})
  |> filter(fn: (r) => r["_field"] == "usage")
  |> filter(fn: (r) => r["_measurement"] == "usage")
  |> filter(fn: (r) => r["device_name"] == "utility meter")"""
            if fuel == "gas":
                query += '\n  |> filter(fn: (r) => r["energy"] == "gas" )'
            elif fuel == "electricity_import":
                query += '\n  |> filter(fn: (r) => r["export"] == "False" and r["energy"] == "electricity" )'
            elif fuel == "electricity_export":
                query += '\n  |> filter(fn: (r) => r["export"] == "True" and r["energy"] == "electricity" )'
            else:
                assert 0, fuel
            print(query)
            r = query_api.query(org="Reed", query=query)
            count = 0
            for series in r:
                for row in series:
                    rowt = row["_time"]
                    fuel_usage.setdefault(rowt, dict())
                    fuel_usage[rowt][fuel] = row["_value"]
                    day = rowt.replace(hour=12, minute=0, second=0, microsecond=0)
                    days_count.setdefault(day, 0)
                    days_count[day] += 1
                    count += 1
            print("matches", count)
    for t in sorted(fuel_usage.keys()):
        # if usage[-1][0] < last_full_data:
        #     last_full_data= usage[-1][0]
        # fuel_usage[gas] = usage

        # running_total = tot.value if tot else 0
        # for tp, v in sorted(usage):
        #     tariff = get_tariff(tp, meters)
        #     print(tariff)
        #     cost = (
        #         tariff.gas_import_rate * v / 1000
        #         + (tariff.gas_sc if tp.hour == 0 and tp.minute < 30 else 0)
        #     ) / 100

        #     running_total += cost
        #     print(
        #         f"@{tp} Wh={v} fuel={fuel} cost={cost} running_total={running_total}"
        #     )
        pass
    print("days with full data")
    days_with_full_data = [
        k for k in days_count if days_count[k] == 24 * 2 * len(fuels)
    ]
    for day in days_with_full_data:
        print("working out from meter readings on", day)
        costs = {}
        sc = 0
        for t in fuel_usage:
            if t.year == day.year and t.month == day.month and t.day == day.day:
                tariff = get_tariff(t, meters)
                costs["sc"] = (tariff.gas_sc + tariff.electric_sc) / 100
                for fuel in fuels:
                    usage = fuel_usage[t][fuel]
                    if fuel == "gas":
                        rate = tariff.gas_import_rate
                    elif fuel == "electricity_import":
                        if usage < 0:
                            rate = tariff.electric_export_rate
                        else:
                            rate = tariff.electric_import_rate
                    elif fuel == "electricity_export":
                        rate = tariff.electric_export_rate
                    else:
                        assert 0, fuel
                    costs.setdefault(fuel, 0)
                    costs[fuel] += (rate * usage / 1000) / 100
        print(day, "cost", costs, sum(costs.values()))


def work_out_gas_consumption(t0, t1):
    acc = []
    query2 = f"""
    from(bucket: "56new")
|> range(start: {t0.strftime('%Y-%m-%dT%H:%M:%SZ')}, stop: {t1.strftime('%Y-%m-%dT%H:%M:%SZ')})
|> filter(fn: (r) => r["_measurement"] == "usage")
|> filter(fn: (r) => r["_field"] == "usage")
|> filter(fn: (r) => r["device_name"] == "utility meter")
|> filter(fn: (r) => r["energy"] == "gas" )
    |> map(fn: (r) => ({{ r with _value: r._value * 2.0 }}))
    """
    resl2 = query_api.query(org="Reed", query=query2)

    if len(resl2) == 0:
        gas_kw = 0
    else:
        gas_consumption_hh_kwh = [x for x in resl2[0]]
        gas_kw = gas_consumption_hh_kwh[0]["_value"] * 0.95 * 2 / 1000.0
        print("gas consumption", gas_consumption_hh_kwh)

    for side in ["boiler", "house"]:
        query = f"""
        from(bucket: "56new")
    |> range(start: {t0.strftime('%Y-%m-%dT%H:%M:%SZ')}, stop: {t1.strftime('%Y-%m-%dT%H:%M:%SZ')})
    |> filter(fn: (r) => r["_measurement"] == "temperature")
    |> filter(fn: (r) => r["_field"] == "temperature")
    |> filter(fn: (r) => r["location"] == "{side}_deltat")
    |> aggregateWindow(every: 30m, fn: mean, createEmpty: false)
    |> yield(name: "mean")
    """
        resl = query_api.query(org="Reed", query=query)
        deltat = [x for x in resl[0]][0]["_value"]
        if deltat > 0:
            flow_rate_lph = 3600 * gas_kw / (4.2 * deltat)
        else:
            flow_rate_lph = 0
        print(
            "********",
            side,
            "deltat=",
            deltat,
            "power=",
            gas_kw,
            "flow_rate=",
            flow_rate_lph,
        )
        acc.append(
            {
                "measurement": "flow_rate",
                "tags": {"location": side},
                "time": (t0 + datetime.timedelta(minutes=15)).strftime(
                    "%Y-%m-%dT%H:%M:%SZ"
                ),
                "fields": {"flow_rate_lph": float(flow_rate_lph)},
            }
        )
    return acc


def model(t, meters):
    """Run the model for time t, linear progresisng from the previous half hour results"""
    # count_meters(t, meters)
    actuals = {
        fuel: get_starting_balance(t, measurement="actual_" + fuel + "_cost")
        for fuel in fuels
    }

    print(actuals)
    prev_balances = {
        s: get_starting_balance(t, system=s, measurement="balance") for s in systems
    }
    baltround = round30m(prev_balances["solar"].t)
    tnext = baltround + datetime.timedelta(minutes=30)
    # print(f'balance={bal} at balt={balt} baltround={baltround}; t={t} tnext={tnext} past={tnext < t}')
    now = (datetime.datetime.utcnow()).replace(tzinfo=datetime.timezone.utc)
    if tnext > now:
        st = (tnext - now).seconds
        print("wait", st)
        time.sleep(st)
    tround = tnext
    tariff = get_tariff(tround, meters)

    # print(f'modelling for {tnext}')
    if tround.hour == 0 and tround.minute == 0:
        charge = tariff.electric_sc + tariff.gas_sc
    else:
        charge = 0
    tariff = get_tariff(tround, meters)

    # work out estimated usage in period
    costs, new_balances = estimate_electricity_costs(meters, prev_balances, tround)

    # now write the balances to influx
    acc = []
    for system in systems:
        acc.append(
            {
                "measurement": "balance",
                "tags": {"system": system},
                "time": tround.strftime("%Y-%m-%dT%H:%M:%SZ"),
                "fields": {"price": float(new_balances[system].total)},
            }
        )
        acc.append(
            {
                "measurement": "charge",
                "tags": {"system": system},
                "time": tround.strftime("%Y-%m-%dT%H:%M:%SZ"),
                "fields": {"price": costs[system]},
            }
        )
        if system != "conventional":
            acc.append(
                {
                    "measurement": "saving",
                    "tags": {"system": system},
                    "time": tround.strftime("%Y-%m-%dT%H:%M:%SZ"),
                    "fields": {
                        "price": float(
                            new_balances["conventional"].total
                            - new_balances[system].total
                        )
                    },
                }
            )

    acc += work_out_gas_consumption(t, t + datetime.timedelta(minutes=30))
    print(acc)
    write_api.write("modelcost", "Reed", acc)
    return tround + datetime.timedelta(minutes=30)


def estimate_electricity_costs(meters, prev_balances, t):
    """Given meters, and previous balances, work out electricty costs and new balances at t"""
    tariff = get_tariff(t, meters)
    trad_tariff = get_tariff(t, meters, traditional_rate=True)

    costs = None
    if t.hour == 0 and t.minute == 0:
        charge = tariff.electric_sc + tariff.gas_sc
    else:
        charge = 0
    if t < txover:
        # no powerwalls; rely on Vue
        tstr = f"""        |> range(start:{t.strftime('%Y-%m-%dT%H:%M:%SZ')}, stop: {(t+datetime.timedelta(minutes=29)).strftime('%Y-%m-%dT%H:%M:%SZ')})"""

        query = f"""
        from(bucket: "vue") {tstr}
        |> filter(fn: (r) => r["_measurement"] == "energy_usage")
        |> filter(fn: (r) => r["_field"] == "usage")
        |> filter(fn: (r) => r["account_name"] == "Primary Residence")
        |> filter(fn: (r) => r["detailed"] == "False")
        |> filter(fn: (r) => r["device_name"] == "Home-TotalUsage")
        |> filter(fn: (r) => r._value > 0.0)
        |> aggregateWindow(every: 30m, fn: mean, createEmpty: false)
        |> yield(name: "last")
        """
        kwh_produced = None
        kwh_used = None
        resl = query_api.query(org="Reed", query=query)
        if len(resl) != 1:
            print("bad", query, resl)
        else:
            data = [x["_value"] for x in resl[0]]
            kwh_used = data[0] / (2 * 1000)
        fquery = f"""
        from(bucket: "vue") |> range(start: {t.strftime('%Y-%m-%dT%H:%M:%SZ')}, stop: {(t+datetime.timedelta(minutes=29)).strftime('%Y-%m-%dT%H:%M:%SZ')}) 
          |> filter(fn: (r) => r["_field"] == "usage")
  |> filter(fn: (r) => r["account_name"] == "Primary Residence")
  |> filter(fn: (r) => r["detailed"] == "True")
  |> filter(fn: (r) => r["device_name"] == "SolarEdge Inverter")
  |> aggregateWindow(every: 30m, fn: mean, createEmpty: false) """
        resl = query_api.query(org="Reed", query=fquery)
        if resl:
            values = [-x["_value"] for x in resl[0]]
            if values and values[0] > 10:
                kwh_produced = values[0] / (2 * 1000)
        print(f"kwh used={kwh_used} produced={kwh_produced}")
        if not kwh_used is None and not kwh_produced is None:
            net_flow = kwh_used - kwh_produced
            export_payment = min(net_flow, 0) * costs.electric_export_rate
            import_payment = max(0, net_flow) * costs.electric_import_rate

            des = f"kwh used={kwh_used} net_flow={net_flow} import payment={import_payment} (rate {import_rate}) export_payment={export_payment} (rate {export_rate})"
            costs = {
                "solar": (export_payment + import_payment) / 100,
                "conventional": kwh_used * full_import_rate / 100,
            }
    else:
        # work out estimated usage after powerwalls install
        prev = retreive_tesla_meters_before(prev_balances["solar"].t)
        data = retreive_tesla_meters_before(t)
        if data and prev:
            reading_interval = data["t"] - prev["t"]
            if reading_interval > datetime.timedelta(minutes=90):
                print(
                    "illegal meter interval",
                    prev,
                    "to",
                    data,
                    "interval",
                    reading_interval,
                )
            else:
                # print('acceptable meter interval', reading_interval, prev, 'to',data)
                days_elapsed = (
                    t.replace(hour=0, minute=0, second=0, microsecond=0)
                    - prev_balances["solar"].t.replace(
                        hour=0, minute=0, second=0, microsecond=0
                    )
                ).days
                # print(f'at {tround} days elasped {days_elapsed}')
                charges = ((tariff.electric_sc + tariff.gas_sc) / 100.0) * days_elapsed
                kwh_cost = tariff.electric_import_rate / 100.0
                full_kwh_cost = trad_tariff.electric_import_rate / 100.0
                out_pay = tariff.electric_export_rate / 100.0
                delta = {}
                for k in field_list:
                    delta[k] = (data[k] - prev[k]) / 1000.0
                des = f"delta {delta} import_rate={tariff.electric_import_rate} full_import_rate={tariff.electric_import_rate} export_rate={tariff.electric_export_rate}"
                costs = {
                    "solar": charges
                    + -delta["site_out"] * out_pay
                    + delta["site_in"] * kwh_cost,
                    "conventional": charges + delta["load"] * full_kwh_cost,
                }

    if costs is None:
        # we couldn't estimate use from vue and powerwall data, so use a model
        print("data gap", t, "using model")
        kwh_used = mean_time_of_day_kwh_used[f"{t.hour:02d}:{t.minute:02d}"] / 2000
        kwh_produced = (
            lat_long_solar_model.get(get_solar_position_index(t), (0, 0))[0]
            * model_scale
            / 2000
        )
        print(f"modelled kwh used={kwh_used} produced={kwh_produced}")
        net_flow = kwh_used - kwh_produced
        export_payment = min(net_flow, 0) * tariff.electric_export_rate  # 0 or negative
        import_payment = max(0, net_flow) * tariff.electric_import_rate

        des = f"modelled kwh used={kwh_used} net_flow={net_flow} import payment={import_payment} (rate {tariff.electric_import_rate}) export_payment={export_payment} (rate {tariff.electric_export_rate})"
        costs = {
            "solar": (export_payment + import_payment) / 100,
            "conventional": (kwh_used * trad_tariff.electric_import_rate) / 100,
        }
    # work out new balances with costs added, marked with the appropriate time
    new_balances = {
        s: LedgerEntry(
            system=s,
            measurement="balance",
            t=t,
            total=(prev_balances[s].total + costs[s]),
        )
        for s in systems
    }
    print(f"{t} costs={costs} charge={charge} des={des} bal={new_balances} ")
    return costs, new_balances


def main():
    meters = determine_meters()
    pprint.pprint(meters)
    t = (datetime.datetime.utcnow()).replace(
        tzinfo=datetime.timezone.utc
    ) - datetime.timedelta(days=2)
    # t = t_ovo_leave + datetime.timedelta(minutes=30)
    # t = isoparse('2023-03-20T00:00:00Z')
    # t = isoparse('2023-08-07T10:00:00Z')
    # ot = isoparse("2022-11-01T10:00:00Z")
    # t = tesla0
    costs = get_tariff(t, meters)
    print("current costs", costs)
    print("traditional costs", get_tariff(t, meters, traditional_rate=True))
    n = 0
    while True:
        try:
            t = model(t, meters)
            n += 1
        except:
            traceback.print_exc()
            time.sleep(60)
        # if n > 48: break
        print()


if __name__ == "__main__":
    main()

# %%
